<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <link rel="stylesheet" href="index.css" />
  <style>
.modal {
  display: none;
  position: fixed;
  z-index: 2000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.6);
  justify-content: center;
  align-items: center;
}
.modal-content {
  background: #1e1e2f;
  color: #fff;
  padding: 20px;
  border-radius: 12px;
  width: 320px;
  max-width: 90%;
  text-align: left;
  position: relative;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  animation: fadeIn 0.3s ease;
}
.close-btn {
  position: absolute;
  top: 8px;
  right: 12px;
  font-size: 22px;
  color: #bbb;
  cursor: pointer;
}
.close-btn:hover {
  color: #fff;
}
@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
}
@keyframes loadingAnim {
  0% { width: 0%; }
  50% { width: 100%; }
  100% { width: 0%; }
}
  </style>
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  <script src="https://unpkg.com/osmtogeojson/osmtogeojson.js"></script>
  <script src="https://unpkg.com/leaflet-shadow-simulator/dist/leaflet-shadow-simulator.umd.min.js"></script>
  <script>
    // Google Maps initialization and autocomplete setup
    function initGoogle() {
      // called by Google JS API once loaded
      directionsService = new google.maps.DirectionsService();
      const acOptions = {
        fields: ["geometry", "name", "formatted_address"],
        componentRestrictions: { country: "us" },
        types: ['geocode']
      };
      try {
        new google.maps.places.Autocomplete(document.getElementById('start-input'), acOptions);
        new google.maps.places.Autocomplete(document.getElementById('end-input'), acOptions);
      } catch (e) { console.warn('Autocomplete init failed', e); }
      window.googleReady = true;
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAooLbj4D5s7PWTL5-Q_j1Pl7VN7NzKdHY&libraries=places,geometry&callback=initGoogle"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  
  <title>Live Sunlight, Shadows, and Routes</title>
</head>

<body>

  <div id="time-display" style="position: absolute; top: 10px; left: 10px; z-index: 2000; font-size: 18px; font-weight: bold; background: rgba(255,255,255,0.7); padding: 6px 10px; border-radius: 6px;">
  </div>


  <div class="route-controls">
    <strong class="">Route</strong>

    <input id="start-input" type="text" placeholder="Startpoint" />
    <input id="end-input" type="text" placeholder="Endpoint" />
    <div class="sun-exposure-control">
      <label for="pick-map-type">Prefer </label>
      <select name="pick-map-type" id="prefer-shade">
        <option value="Shade">Shade</option>
        <option value="Safety">Safety</option>
        <option value="Speed">Speed</option>
      </select>
    </div>
    <button id="route-btn">Find Routes</button>
    <div id="route-loading" style="display:none; margin-top:10px; text-align:center;">
      <div style="width:80%; height:6px; background:#ddd; border-radius:4px; margin:0 auto; overflow:hidden;">
        <div id="route-progress" style="width:0%; height:100%; background:#1976d2; animation: loadingAnim 2s infinite;"></div>
      </div>
      <small style="color:#555;">Rerouting...</small>
    </div>
  </div>

  <!--
  <div class="legend">
    <div><span class="swatch" style="background:#1976d2"></span> Best route</div>
    <div><span class="swatch" style="background:#9e9e9e"></span> Alternative</div>
  </div>
  -->
  <div id="mapid"></div>
  <div id="playback-controls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; background: rgba(255,255,255,0.8); padding: 6px 12px; border-radius: 8px; display: flex; gap: 6px; align-items: center;">
    <button id="decrement"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
        class="bi bi-skip-backward-fill" viewBox="0 0 16 16">
        <path
          d="M.5 3.5A.5.5 0 0 0 0 4v8a.5.5 0 0 0 1 0V8.753l6.267 3.636c.54.313 1.233-.066 1.233-.697v-2.94l6.267 3.636c.54.314 1.233-.065 1.233-.696V4.308c0-.63-.693-1.01-1.233-.696L8.5 7.248v-2.94c0-.63-.692-1.01-1.233-.696L1 7.248V4a.5.5 0 0 0-.5-.5" />
      </svg></button>
    <button id="stop"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
        class="bi bi-stop-fill" viewBox="0 0 16 16">
        <path
          d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5" />
      </svg></button>
    <button id="play"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
        class="bi bi-play-fill" viewBox="0 0 16 16">
        <path
          d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393" />
      </svg></button>

    <button id="increment"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
        class="bi bi-skip-forward-fill" viewBox="0 0 16 16">
        <path
          d="M15.5 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V8.753l-6.267 3.636c-.54.313-1.233-.066-1.233-.697v-2.94l-6.267 3.636C.693 12.703 0 12.324 0 11.693V4.308c0-.63.693-1.01 1.233-.696L7.5 7.248v-2.94c0-.63.693-1.01 1.233-.696L15 7.248V4a.5.5 0 0 1 .5-.5" />
      </svg></button>

    <!-- <label><input id="exposure" type="checkbox" autocomplete="off" />Full-day sun exposure</label> -->
    <span id="loader" style="padding: 3px;"></span>
  </div>

  <!-- Filter Controls: bottom right corner, outside playback-controls -->
  <div id="filter-controls" style="position: absolute; bottom: 100px; right: 10px; z-index: 2100;">
    <button id="filter-btn" style="padding: 8px; border-radius: 8px; font-size: 14px; cursor: pointer; background: #1976d2; color: #fff; border: none; font-weight: bold; box-shadow: 0 2px 6px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center;">
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" style="display:block;" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 5h14M6 10h8M9 15h2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </button>
    <div id="filter-panel" style="display: none; background: #fff; border-radius: 10px; box-shadow: 0 2px 12px rgba(0,0,0,0.13); padding: 12px 20px; margin-top: 8px;">
      <label style="display: block; margin-bottom: 8px;">
        <input type="checkbox" id="toggle-water" checked />
        Water Stations
      </label>
      <label style="display: block;">
        <input type="checkbox" id="toggle-emergency" checked />
        Emergency Boxes
      </label>
    </div>
  </div>

  <script>
    /* Leaflet setup */
    var map = L.map("mapid", { zoomControl: false }).setView([47.6062, -122.3321], 14); // fallback Seattle
    const increment = document.getElementById('increment');
    const decrement = document.getElementById('decrement');
    const play = document.getElementById('play');
    const stopBtn = document.getElementById('stop');
    const exposure = document.getElementById('exposure');
    const exposureGradientContainer = document.getElementById('exposure-gradient-container');
    const exposureGradient = document.getElementById('exposure-gradient');

    // Timers and state for time/shadow animation and routing cache
    let baseTimerId = null;   // real-time minute tick
    let animTimerId = null;   // fast playback tick
    let isPlaying = false;
    let lastDirectionsResult = null; // cache last Google Directions response

    // Holders for shaded scoring and drawn polylines
    let BUILDING_LINES = []; // turf LineString features from OSM building polygons
    let drawnRoutes = [];    // Leaflet polylines for current routes
    let directionsService;   // Google Directions service instance

    L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution:
        'Map data © <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 18,
    }).addTo(map);

    L.control.zoom({ position: 'bottomright' }).addTo(map);

    // Try to use browser location
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition((pos) => {
        const { latitude, longitude } = pos.coords;
        map.setView([latitude, longitude], 16);
      });
    }

    /* ShadeMap setup */
    const loaderEl = document.getElementById('loader');
    let now = new Date();

    const timeDisplay = document.getElementById('time-display');
    function updateTimeDisplay() {
      if (timeDisplay) {
        // Use the simulation time 'now'
        timeDisplay.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
      }
    }
    // Update every second for live time display in real time
    setInterval(() => {
      if (!isPlaying) {
        // Only update when not simulating
        now = new Date();
        shadeMap.setDate(now);
        updateTimeDisplay();
        // Optionally rerender routes if needed
      }
    }, 1000);
    updateTimeDisplay();
    function startBaseClock() {
      if (baseTimerId) return;
      baseTimerId = setInterval(() => {
        if (!isPlaying) {
          now = new Date();
          shadeMap.setDate(now);
          updateTimeDisplay();
          if (lastDirectionsResult) {
            renderRoutesWithShade(lastDirectionsResult, preferShadeChk.value === 'Shade');
          }
        }
      }, 60000);
    }

    function addImageMarker(lat, lng, imageUrl, opts = {}) {
      const {
        iconSize = [32, 32],
        iconAnchor = [16, 32],
        popupText,
        pane = 'markerPane',
        zIndexOffset = 0,
        draggable = false,
        className
      } = opts;

      if (pane !== 'markerPane' && !map.getPane(pane)) {
        map.createPane(pane);
        map.getPane(pane).style.zIndex = 650;
      }

      const popupAnchor = [0, -Math.max(0, iconSize[1] - iconAnchor[1])];

      const icon = L.icon({
        iconUrl: imageUrl,
        iconSize,
        iconAnchor,
        popupAnchor,
        className
      });

      const marker = L.marker([lat, lng], {
        icon,
        pane,
        zIndexOffset,
        draggable
      }).addTo(map);

      if (popupText) marker.bindPopup(popupText);

      return marker;
    }

    // Arrays to hold references to water and emergency box markers
    let WATER_MARKERS = [];
    let EMER_MARKERS = [];

    function drawWater() {
      fetch('./waterStations.json')
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(jsonData => {
          for (let i = 0; i < jsonData.features.length; i++) {
            if (jsonData.features[i].geometry.y !== "NaN") {
              const marker = addImageMarker(jsonData.features[i].geometry.y, jsonData.features[i].geometry.x, 'assets/water-circle.png', {
                iconSize: [48, 48],
                iconAnchor: [24, 48],
                popupText: 'water',
                zIndexOffset: 1001
              });
              WATER_MARKERS.push(marker);
            }
          }
        })
        .catch(error => { console.error('Error fetching or parsing JSON:', error); })
    }

    function drawEmer() {
      fetch('./emergencyCallBoxes.json')
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(jsonData => {
          for (let i = 0; i < jsonData.features.length; i++) {
            if (jsonData.features[i].geometry.y !== "NaN") {
              const marker = addImageMarker(jsonData.features[i].geometry.y, jsonData.features[i].geometry.x, 'assets/emergency_pin.png', {
                iconSize: [48, 48],
                iconAnchor: [24, 48],
                popupText: 'emer',
                zIndexOffset: 1001
              });
              EMER_MARKERS.push(marker);
            }
          }
        })
        .catch(error => { console.error('Error fetching or parsing JSON:', error); })
    }

    drawWater();
    drawEmer();

    function drawPolice() {
      fetch('./policeStations.json')
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(jsonData => {
          for (let i = 0; i < jsonData.features.length; i++) {
            if (jsonData.features[i].geometry.y !== "NaN") {
              addImageMarker(jsonData.features[i].geometry.y, jsonData.features[i].geometry.x, 'assets/police_pin.png', {
                iconSize: [48, 48],
                iconAnchor: [24, 48],
                popupText: 'popo',
                zIndexOffset: 1001
              });
            }

          }
        })
        .catch(error => { console.error('Error fetching or parsing JSON:'.error); })
    }

    drawPolice()

    function stopBaseClock() {
      if (baseTimerId) {
        clearInterval(baseTimerId);
        baseTimerId = null;
      }
    }
    startBaseClock();

    const shadeMap = L.shadeMap({
      apiKey: "eyJhbGciOiJIUzI1NiJ9.eyJlbWFpbCI6ImF1c21hbjhAYXN1LmVkdSIsImNyZWF0ZWQiOjE3NTkwMTk4MzE4ODEsImlhdCI6MTc1OTAxOTgzMX0.IB8uw5Yi-brW-OJer_IKtEJvtlG-_kttmyK3lTltckc",
      date: now,
      color: '#01112f',
      opacity: 0.7,
      terrainSource: {
        maxZoom: 15,
        tileSize: 256,
        getSourceUrl: ({ x, y, z }) =>
          `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`,
        getElevation: ({ r, g, b }) => (r * 256 + g + b / 256) - 32768,
        _overzoom: 18,
      },
      getFeatures: async () => {
        try {
          const bounds = map.getBounds();
          const north = bounds.getNorth();
          const south = bounds.getSouth();
          const east = bounds.getEast();
          const west = bounds.getWest();
          const query = `https://overpass-api.de/api/interpreter?data=[out:json][timeout:25];(way["building"](${south},${west},${north},${east}););out body;>;out skel qt;`;
          const response = await fetch(query);
          const json = await response.json();
          const geojson = osmtogeojson(json);
          // Cache building edges as LineStrings for distance checks
          BUILDING_LINES = [];
          geojson.features.forEach(f => {
            if (!f.geometry) return;
            if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
              const g = f.geometry;
              try {
                const line = turf.polygonToLine({ type: 'Feature', properties: {}, geometry: g });
                if (line.type === 'Feature') BUILDING_LINES.push(line);
                if (line.type === 'FeatureCollection') BUILDING_LINES.push(...line.features);
              } catch (_) { }
            }
          });
          geojson.features.forEach(feature => {
            if (!feature.properties) feature.properties = {};
            if (!feature.properties.height) feature.properties.height = 3;
          });
          return geojson.features;
        } catch (e) {
          console.error(e);
        }
        return [];
      },
      debug: (msg) => { console.log(new Date().toISOString(), msg); }
    }).addTo(map);

    shadeMap.on('tileloaded', () => {
      loaderEl.innerText = '';
    });

    async function fetchBuildingsForBounds(north, south, east, west) {
      try {
        const query = `https://overpass-api.de/api/interpreter?data=[out:json][timeout:25];(way["building"](${south},${west},${north},${east}););out body;>;out skel qt;`;
        const response = await fetch(query);
        const json = await response.json();
        const geojson = osmtogeojson(json);
        BUILDING_LINES = [];
        geojson.features.forEach(f => {
          if (!f.geometry) return;
          if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
            const g = f.geometry;
            try {
              const line = turf.polygonToLine({ type: 'Feature', properties: {}, geometry: g });
              if (line.type === 'Feature') BUILDING_LINES.push(line);
              if (line.type === 'FeatureCollection') BUILDING_LINES.push(...line.features);
            } catch (_) { }
          }
        });
        return true;
      } catch (e) {
        console.error('Building fetch error', e);
        return false;
      }
    }

    function decodeRouteToLatLngs(route) {
      if (route.overview_path && route.overview_path.length) {
        return route.overview_path.map(p => L.latLng(p.lat(), p.lng()));
      }
      if (route.overview_polyline && route.overview_polyline.points && google.maps.geometry && google.maps.geometry.encoding) {
        const arr = google.maps.geometry.encoding.decodePath(route.overview_polyline.points);
        return arr.map(p => L.latLng(p.lat(), p.lng()));
      }
      return [];
    }

    function computeBoundsFromRoutes(result) {
      let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
      (result.routes || []).forEach(r => {
        const ll = decodeRouteToLatLngs(r);
        ll.forEach(pt => {
          if (pt.lat > maxLat) maxLat = pt.lat;
          if (pt.lat < minLat) minLat = pt.lat;
          if (pt.lng > maxLng) maxLng = pt.lng;
          if (pt.lng < minLng) minLng = pt.lng;
        });
      });
      if (minLat > maxLat || minLng > maxLng) return null;
      const pad = 0.0015; // ~150m
      return { north: maxLat + pad, south: minLat - pad, east: maxLng + pad, west: minLng - pad };
    }

    // using decodeRouteToLatLngs(route) instead of latLngArrayToLeaflet

    function scoreRouteByShade(latlngs) {
      if (!latlngs.length) return Number.POSITIVE_INFINITY;

      // Try to use real shadow polygons from shadeMap if available
      let shadowFeatures = null;
      try {
        if (shadeMap && typeof shadeMap.getShadowFeatures === 'function') {
          shadowFeatures = shadeMap.getShadowFeatures();
        }
      } catch (_) { }

      if (shadowFeatures && shadowFeatures.features && shadowFeatures.features.length) {
        let inShadow = 0;
        let total = 0;
        const step = Math.max(1, Math.floor(latlngs.length / 200));
        for (let i = 0; i < latlngs.length; i += step) {
          const pt = turf.point([latlngs[i].lng, latlngs[i].lat]);
          for (const feature of shadowFeatures.features) {
            try {
              if (turf.booleanPointInPolygon(pt, feature)) {
                inShadow++;
                break;
              }
            } catch (_) { }
          }
          total++;
        }
        // More shaded = better (lower score)
        return total ? 1 - (inShadow / total) : 1;
      }

      // Fallback: average distance to building edges if no shadow features
      if (!BUILDING_LINES.length) return Number.POSITIVE_INFINITY;
      const sampleStep = Math.max(1, Math.floor(latlngs.length / 200));
      let total = 0, count = 0;
      for (let i = 0; i < latlngs.length; i += sampleStep) {
        const pt = turf.point([latlngs[i].lng, latlngs[i].lat]);
        let best = Infinity;
        for (let k = 0; k < BUILDING_LINES.length; k++) {
          const ln = BUILDING_LINES[k];
          try {
            const snapped = turf.nearestPointOnLine(ln, pt, { units: 'meters' });
            if (snapped && snapped.properties && typeof snapped.properties.dist === 'number') {
              if (snapped.properties.dist < best) best = snapped.properties.dist;
            }
          } catch (_) { }
        }
        if (isFinite(best)) { total += best; count++; }
      }
      return count ? (total / count) : Number.POSITIVE_INFINITY;
    }

    function clearRoutes() {
      drawnRoutes.forEach(l => map.removeLayer(l));
      drawnRoutes = [];
    }

    function drawRoutes(result, preferShade) {
      clearRoutes();
      if (!result || !result.routes || !result.routes.length) return;

      const candidates = result.routes.map((r, idx) => {
        const ll = decodeRouteToLatLngs(r);
        const score = scoreRouteByShade(ll);
        return { idx, latlngs: ll, score };
      }).filter(c => c.latlngs.length);

      if (!candidates.length) return;

      let bestIndex = 0;
      if (preferShade && BUILDING_LINES.length) {
        let bestScore = Infinity;
        candidates.forEach(c => { if (c.score < bestScore) { bestScore = c.score; bestIndex = c.idx; } });
      }

      candidates.forEach(c => {
        const isBest = c.idx === bestIndex;
        const line = L.polyline(c.latlngs, {
          color: isBest ? '#1976d2' : '#9e9e9e',
          weight: isBest ? 6 : 4,
          opacity: isBest ? 0.95 : 0.7
        }).addTo(map);
        drawnRoutes.push(line);
      });

      const best = candidates.find(c => c.idx === bestIndex);
      if (best) map.fitBounds(L.latLngBounds(best.latlngs), { padding: [30, 30] });
    }

    async function renderRoutesWithShade(result, preferShade) {
      const b = computeBoundsFromRoutes(result);
      if (b) {
        await fetchBuildingsForBounds(b.north, b.south, b.east, b.west);
      }
      drawRoutes(result, preferShade);
    }


    /* Controls setup */
    // Google Directions service is created in initGoogle() after async load

    const startInput = document.getElementById('start-input');
    const endInput = document.getElementById('end-input');
    const routeBtn = document.getElementById('route-btn');
    const preferShadeChk = document.getElementById('prefer-shade');

    async function requestRoutes(origin, destination) {
      if (!window.googleReady || !directionsService) throw new Error('Google API not ready');
      return new Promise((resolve, reject) => {
        directionsService.route({
          origin,
          destination,
          travelMode: google.maps.TravelMode.WALKING,
          provideRouteAlternatives: true,
          optimizeWaypoints: false
        }, (result, status) => {
          if (status === 'OK' || status === google.maps.DirectionsStatus?.OK) resolve(result);
          else reject(new Error('Directions request failed: ' + status));
        });
      });
    }

    routeBtn.addEventListener('click', async () => {
      const origin = startInput.value.trim();
      const destination = endInput.value.trim();
      if (!origin || !destination) { alert('Enter start and end.'); return; }
      // Stop any running timers while routing
      if (animTimerId) { clearInterval(animTimerId); animTimerId = null; }
      stopBaseClock();
      routeBtn.disabled = true;
      loaderEl.innerText = 'Routing...';
      document.getElementById('route-loading').style.display = 'block';
      try {
        const result = await requestRoutes(origin, destination);
        lastDirectionsResult = result;
        await renderRoutesWithShade(result, preferShadeChk.value === 'Shade');
        loaderEl.innerText = '';
      } catch (err) {
        console.error(err);
        loaderEl.innerText = 'Route error';
        alert('Could not fetch routes. Check API key and inputs.');
      } finally {
        routeBtn.disabled = false;
        document.getElementById('route-loading').style.display = 'none';
      }
    });

    preferShadeChk.addEventListener('change', async () => {
      if (lastDirectionsResult) {
        loaderEl.innerText = 'Scoring...';
        await renderRoutesWithShade(lastDirectionsResult, preferShadeChk.value !== 'Shade');
        loaderEl.innerText = '';
      }
    });

    increment.addEventListener('click', async () => {
      now = new Date(now.getTime() + 3600000);
      shadeMap.setDate(now);
      updateTimeDisplay();
      if (lastDirectionsResult) {
        await renderRoutesWithShade(lastDirectionsResult, preferShadeChk.value === 'Shade');
      }
    });

    decrement.addEventListener('click', async () => {
      now = new Date(now.getTime() - 3600000);
      shadeMap.setDate(now);
      updateTimeDisplay();
      if (lastDirectionsResult) {
        await renderRoutesWithShade(lastDirectionsResult, preferShadeChk.value === 'Shade');
      }
    });

    play.addEventListener('click', () => {
      if (animTimerId) { clearInterval(animTimerId); animTimerId = null; }
      stopBaseClock();
      isPlaying = true;
      animTimerId = setInterval(async () => {
        now = new Date(now.getTime() + 60000); // +1 minute per tick
        shadeMap.setDate(now);
        updateTimeDisplay();
        if (lastDirectionsResult) {
          await renderRoutesWithShade(lastDirectionsResult, preferShadeChk.value === 'Shade');
        }
      }, 100);
    });

    stopBtn.addEventListener('click', () => {
      if (animTimerId) {
        clearInterval(animTimerId);
        animTimerId = null;
      }
      isPlaying = false;
      startBaseClock();
      // Sync everything to new time
      shadeMap.setDate(now);
      updateTimeDisplay();
      if (lastDirectionsResult) {
        renderRoutesWithShade(lastDirectionsResult, preferShadeChk.value === 'Shade');
      }
    });

    // exposure.addEventListener('click', (e) => {
    //   const target = e.target;
    //   if (!target.checked) {
    //     shadeMap && shadeMap.setSunExposure(false);
    //     increment.disabled = false;
    //     decrement.disabled = false;
    //     play.disabled = false;
    //     stopBtn.disabled = false;
    //     exposureGradientContainer.style.display = 'none';
    //   } else {
    //     const { lat, lng } = map.getCenter();
    //     const { sunrise, sunset } = SunCalc.getTimes(now, lat, lng);
    //     shadeMap && shadeMap.setSunExposure(true, {
    //       startDate: sunrise,
    //       endDate: sunset
    //     });
    //     increment.disabled = true;
    //     decrement.disabled = true;
    //     play.disabled = true;
    //     stopBtn.disabled = true;
    //
    //     const hours = (sunset - sunrise) / 1000 / 3600;
    //     const partial = hours - Math.floor(hours);
    //     const html = [];
    //     for (let i = 0; i < hours; i++) {
    //       html.push(`<div>${i + 1}</div>`);
    //     }
    //     html.push(`<div style="flex: ${partial}"></div>`);
    //     exposureGradientContainer.style.display = 'block';
    //     exposureGradient.innerHTML = html.join('');
    //   }
    //   updateTimeDisplay();
    // });

    async function sporkyClicked() {
      try {
        // Get user location
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(async (pos) => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;

            // Reverse geocode with Google Maps
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ location: { lat, lng: lon } }, async (results, status) => {
              let locationName = "your area";
              if (status === "OK" && results[0]) {
                locationName = results[0].formatted_address;
              }

              // Fetch weather from WeatherAPI.com
              let condition = "Weather unavailable";
              let temp = "N/A";
              try {
                const apiKey = "be181c62bd4c4daf8d7164928252809";
                const url = `https://api.weatherapi.com/v1/current.json?key=${apiKey}&q=${lat},${lon}&aqi=no`;
                const response = await fetch(url);
                if (response.ok) {
                  const data = await response.json();
                  if (data && data.current) {
                    temp = data.current.temp_f;
                    condition = data.current.condition && data.current.condition.text ? data.current.condition.text : "Unknown";
                  }
                }
              } catch (err) {
                condition = "Weather unavailable";
                temp = "N/A";
              }

              // Get current local time
              const nowTime = new Date();
              const time = nowTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

              document.getElementById("sporky-message").innerText =
                `Location: ${locationName}\nWeather: ${condition}, ${temp}°F\nTime: ${time}`;
              document.getElementById("sporky-modal").style.display = "flex";
            });
          });
        } else {
          document.getElementById("sporky-message").innerText = "Geolocation not supported on this browser.";
          document.getElementById("sporky-modal").style.display = "flex";
        }
      } catch (err) {
        console.error(err);
        document.getElementById("sporky-message").innerText = "Could not fetch weather info.";
        document.getElementById("sporky-modal").style.display = "flex";
      }
    }


  </script>
<script>
// Filter button show/hide logic
const filterBtn = document.getElementById("filter-btn");
const filterPanel = document.getElementById("filter-panel");
filterBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  filterPanel.style.display = (filterPanel.style.display === "none" || filterPanel.style.display === "") ? "block" : "none";
});
// Hide filter panel when clicking outside of it and the filter button
document.addEventListener("mousedown", function(event) {
  const controls = document.getElementById("filter-controls");
  if (!controls.contains(event.target)) {
    filterPanel.style.display = "none";
  }
});
</script>
</body>

<div id="sporky-modal" class="modal">
  <div class="modal-content">
    <span class="close-btn" id="closeSporky">&times;</span>
    <h2>Sporky says:</h2>
    <p id="sporky-message"></p>
  </div>
</div>

<div id="sporky-gif">
  <button onclick="sporkyClicked()" style="background-color: transparent; border: none;">
    <img src="sporky.gif" alt="Sporky Mascot" />
  </button>
</div>

<script>
document.getElementById("closeSporky").onclick = function() {
  document.getElementById("sporky-modal").style.display = "none";
};
window.onclick = function(event) {
  const modal = document.getElementById("sporky-modal");
  if (event.target === modal) {
    modal.style.display = "none";
  }
};
</script>

</html>


<script>
// Checkbox event listeners for toggling water stations and emergency boxes
document.addEventListener('DOMContentLoaded', function () {
  const toggleWater = document.getElementById('toggle-water');
  const toggleEmer = document.getElementById('toggle-emergency');

  if (toggleWater) {
    toggleWater.addEventListener('change', function () {
      if (toggleWater.checked) {
        WATER_MARKERS.forEach(m => { if (!map.hasLayer(m)) map.addLayer(m); });
      } else {
        WATER_MARKERS.forEach(m => { if (map.hasLayer(m)) map.removeLayer(m); });
      }
    });
  }

  if (toggleEmer) {
    toggleEmer.addEventListener('change', function () {
      if (toggleEmer.checked) {
        EMER_MARKERS.forEach(m => { if (!map.hasLayer(m)) map.addLayer(m); });
      } else {
        EMER_MARKERS.forEach(m => { if (map.hasLayer(m)) map.removeLayer(m); });
      }
    });
  }
});
</script>