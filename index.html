<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <link rel="stylesheet" href="index.css" />
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  <script src="https://unpkg.com/osmtogeojson/osmtogeojson.js"></script>
  <script src="https://unpkg.com/leaflet-shadow-simulator/dist/leaflet-shadow-simulator.umd.min.js"></script>
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAooLbj4D5s7PWTL5-Q_j1Pl7VN7NzKdHY&libraries=places,geometry&callback=initGoogle"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  
  <title>Live Sunlight, Shadows, and Routes</title>
</head>

<body>
  <div id="time-display"></div>
  <div class="route-controls">
    <strong class="">Route</strong>
    
    <input id="start-input" type="text" placeholder="Start, e.g., SDFC ASU" />
    <input id="end-input" type="text" placeholder="End, e.g., Hayden Library ASU" />
    <label><input id="prefer-shade" type="checkbox" checked /> Prefer shade</label>
    <button id="route-btn">Find walking routes</button>
  </div>
  <div class="legend">
    <div><span class="swatch" style="background:#1976d2"></span> Best route</div>
    <div><span class="swatch" style="background:#9e9e9e"></span> Alternative</div>
  </div>
  <div id="mapid"></div>
  <div class="leaflet-control-container">
    <div class="leaflet-top leaflet-left">
      <div class="leaflet-control-time leaflet-control">
        <button id="decrement">-1 hour</button>
        <button id="increment">+1 hour</button>
        <button id="play">Play</button>
        <button id="stop">Stop</button>
        <label><input id="exposure" type="checkbox" autocomplete="off" />Full-day sun exposure</label>
        <span id="loader" style="padding: 3px;"></span>
      </div>
      <div class="leaflet-control-time leaflet-control" id="exposure-gradient-container">
        <div>Hours of sunlight</div>
        <div id="exposure-gradient"></div>
      </div>
    </div>
  </div>

  <script>
    /* Leaflet setup */
    var map = L.map("mapid", { zoomControl: false }).setView([47.6062, -122.3321], 14); // fallback Seattle
    const increment = document.getElementById('increment');
    const decrement = document.getElementById('decrement');
    const play = document.getElementById('play');
    const stopBtn = document.getElementById('stop');
    const exposure = document.getElementById('exposure');
    const exposureGradientContainer = document.getElementById('exposure-gradient-container');
    const exposureGradient = document.getElementById('exposure-gradient');

    // Timers and state for time/shadow animation and routing cache
    let baseTimerId = null;   // real-time minute tick
    let animTimerId = null;   // fast playback tick
    let isPlaying = false;
    let lastDirectionsResult = null; // cache last Google Directions response

    // Holders for shaded scoring and drawn polylines
    let BUILDING_LINES = []; // turf LineString features from OSM building polygons
    let drawnRoutes = [];    // Leaflet polylines for current routes
    let directionsService;   // Google Directions service instance

    L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution:
        'Map data Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 18,
    }).addTo(map);

    L.control.zoom({ position: 'bottomright' }).addTo(map);

    // Try to use browser location
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition((pos) => {
        const { latitude, longitude } = pos.coords;
        map.setView([latitude, longitude], 16);
      });
    }

    /* ShadeMap setup */
    const loaderEl = document.getElementById('loader');
    let now = new Date();

    const timeDisplay = document.getElementById('time-display');
    function updateTimeDisplay() {
      timeDisplay.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
    }
    updateTimeDisplay();
    function startBaseClock() {
      if (baseTimerId) return;
      baseTimerId = setInterval(() => {
        now = new Date();
        shadeMap.setDate(now);
        updateTimeDisplay();
      }, 60000);
    }

    function addImageMarker(lat, lng, imageUrl, opts = {}) {
      const {
        iconSize = [32, 32],
        iconAnchor = [16, 32],
        popupText,
        pane = 'markerPane',
        zIndexOffset = 0,
        draggable = false,
        className
      } = opts;

      if (pane !== 'markerPane' && !map.getPane(pane)) {
        map.createPane(pane);
        map.getPane(pane).style.zIndex = 650;
      }

      const popupAnchor = [0, -Math.max(0, iconSize[1] - iconAnchor[1])];

      const icon = L.icon({
        iconUrl: imageUrl,
        iconSize,
        iconAnchor,
        popupAnchor,
        className
      });

      const marker = L.marker([lat, lng], {
        icon,
        pane,
        zIndexOffset,
        draggable
      }).addTo(map);

      if (popupText) marker.bindPopup(popupText);

      return marker;
    }

    addImageMarker(33.424564, -111.938953, 'assets/sporky.png', {
      iconSize: [48, 48],
      iconAnchor: [24, 48],
      popupText: 'Sporky the Sun Devil',
      zIndexOffset: 1000
    });

    function stopBaseClock() {
      if (baseTimerId) {
        clearInterval(baseTimerId);
        baseTimerId = null;
      }
    }
    startBaseClock();

    const shadeMap = L.shadeMap({
      apiKey: "eyJhbGciOiJIUzI1NiJ9.eyJlbWFpbCI6ImF1c21hbjhAYXN1LmVkdSIsImNyZWF0ZWQiOjE3NTkwMTk4MzE4ODEsImlhdCI6MTc1OTAxOTgzMX0.IB8uw5Yi-brW-OJer_IKtEJvtlG-_kttmyK3lTltckc",
      date: now,
      color: '#01112f',
      opacity: 0.7,
      terrainSource: {
        maxZoom: 15,
        tileSize: 256,
        getSourceUrl: ({ x, y, z }) =>
          `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`,
        getElevation: ({ r, g, b }) => (r * 256 + g + b / 256) - 32768,
        _overzoom: 18,
      },
      getFeatures: async () => {
        try {
          const bounds = map.getBounds();
          const north = bounds.getNorth();
          const south = bounds.getSouth();
          const east = bounds.getEast();
          const west = bounds.getWest();
          const query = `https://overpass-api.de/api/interpreter?data=[out:json][timeout:25];(way["building"](${south},${west},${north},${east}););out body;>;out skel qt;`;
          const response = await fetch(query);
          const json = await response.json();
          const geojson = osmtogeojson(json);
          // Cache building edges as LineStrings for distance checks
          BUILDING_LINES = [];
          geojson.features.forEach(f => {
            if (!f.geometry) return;
            if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
              const g = f.geometry;
              try {
                const line = turf.polygonToLine({ type: 'Feature', properties: {}, geometry: g });
                if (line.type === 'Feature') BUILDING_LINES.push(line);
                if (line.type === 'FeatureCollection') BUILDING_LINES.push(...line.features);
              } catch (_) {}
            }
          });
          geojson.features.forEach(feature => {
            if (!feature.properties) feature.properties = {};
            if (!feature.properties.height) feature.properties.height = 3;
          });
          return geojson.features;
        } catch (e) {
          console.error(e);
        }
        return [];
      },
      debug: (msg) => { console.log(new Date().toISOString(), msg); }
    }).addTo(map);

    shadeMap.on('tileloaded', () => {
      loaderEl.innerText = '';
    });

    async function fetchBuildingsForBounds(north, south, east, west) {
      try {
        const query = `https://overpass-api.de/api/interpreter?data=[out:json][timeout:25];(way["building"](${south},${west},${north},${east}););out body;>;out skel qt;`;
        const response = await fetch(query);
        const json = await response.json();
        const geojson = osmtogeojson(json);
        BUILDING_LINES = [];
        geojson.features.forEach(f => {
          if (!f.geometry) return;
          if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
            const g = f.geometry;
            try {
              const line = turf.polygonToLine({ type: 'Feature', properties: {}, geometry: g });
              if (line.type === 'Feature') BUILDING_LINES.push(line);
              if (line.type === 'FeatureCollection') BUILDING_LINES.push(...line.features);
            } catch (_) {}
          }
        });
        return true;
      } catch (e) {
        console.error('Building fetch error', e);
        return false;
      }
    }

    function decodeRouteToLatLngs(route) {
      if (route.overview_path && route.overview_path.length) {
        return route.overview_path.map(p => L.latLng(p.lat(), p.lng()));
      }
      if (route.overview_polyline && route.overview_polyline.points && google.maps.geometry && google.maps.geometry.encoding) {
        const arr = google.maps.geometry.encoding.decodePath(route.overview_polyline.points);
        return arr.map(p => L.latLng(p.lat(), p.lng()));
      }
      return [];
    }

    function computeBoundsFromRoutes(result) {
      let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
      (result.routes || []).forEach(r => {
        const ll = decodeRouteToLatLngs(r);
        ll.forEach(pt => {
          if (pt.lat > maxLat) maxLat = pt.lat;
          if (pt.lat < minLat) minLat = pt.lat;
          if (pt.lng > maxLng) maxLng = pt.lng;
          if (pt.lng < minLng) minLng = pt.lng;
        });
      });
      if (minLat > maxLat || minLng > maxLng) return null;
      const pad = 0.0015; // ~150m
      return { north: maxLat + pad, south: minLat - pad, east: maxLng + pad, west: minLng - pad };
    }

    // using decodeRouteToLatLngs(route) instead of latLngArrayToLeaflet

    function scoreRouteByShade(latlngs) {
      if (!latlngs.length) return Number.POSITIVE_INFINITY;

      // Try to use real shadow polygons from shadeMap if available
      let shadowFeatures = null;
      try {
        if (shadeMap && typeof shadeMap.getShadowFeatures === 'function') {
          shadowFeatures = shadeMap.getShadowFeatures();
        }
      } catch (_) {}

      if (shadowFeatures && shadowFeatures.features && shadowFeatures.features.length) {
        let inShadow = 0;
        let total = 0;
        const step = Math.max(1, Math.floor(latlngs.length / 200));
        for (let i = 0; i < latlngs.length; i += step) {
          const pt = turf.point([latlngs[i].lng, latlngs[i].lat]);
          for (const feature of shadowFeatures.features) {
            try {
              if (turf.booleanPointInPolygon(pt, feature)) {
                inShadow++;
                break;
              }
            } catch (_) {}
          }
          total++;
        }
        // More shaded = better (lower score)
        return total ? 1 - (inShadow / total) : 1;
      }

      // Fallback: average distance to building edges if no shadow features
      if (!BUILDING_LINES.length) return Number.POSITIVE_INFINITY;
      const sampleStep = Math.max(1, Math.floor(latlngs.length / 200));
      let total = 0, count = 0;
      for (let i = 0; i < latlngs.length; i += sampleStep) {
        const pt = turf.point([latlngs[i].lng, latlngs[i].lat]);
        let best = Infinity;
        for (let k = 0; k < BUILDING_LINES.length; k++) {
          const ln = BUILDING_LINES[k];
          try {
            const snapped = turf.nearestPointOnLine(ln, pt, { units: 'meters' });
            if (snapped && snapped.properties && typeof snapped.properties.dist === 'number') {
              if (snapped.properties.dist < best) best = snapped.properties.dist;
            }
          } catch (_) {}
        }
        if (isFinite(best)) { total += best; count++; }
      }
      return count ? (total / count) : Number.POSITIVE_INFINITY;
    }

    function clearRoutes() {
      drawnRoutes.forEach(l => map.removeLayer(l));
      drawnRoutes = [];
    }

    function drawRoutes(result, preferShade) {
      clearRoutes();
      if (!result || !result.routes || !result.routes.length) return;

      const candidates = result.routes.map((r, idx) => {
        const ll = decodeRouteToLatLngs(r);
        const score = scoreRouteByShade(ll);
        return { idx, latlngs: ll, score };
      }).filter(c => c.latlngs.length);

      if (!candidates.length) return;

      let bestIndex = 0;
      if (preferShade && BUILDING_LINES.length) {
        let bestScore = Infinity;
        candidates.forEach(c => { if (c.score < bestScore) { bestScore = c.score; bestIndex = c.idx; } });
      }

      candidates.forEach(c => {
        const isBest = c.idx === bestIndex;
        const line = L.polyline(c.latlngs, {
          color: isBest ? '#1976d2' : '#9e9e9e',
          weight: isBest ? 6 : 4,
          opacity: isBest ? 0.95 : 0.7
        }).addTo(map);
        drawnRoutes.push(line);
      });

      const best = candidates.find(c => c.idx === bestIndex);
      if (best) map.fitBounds(L.latLngBounds(best.latlngs), { padding: [30, 30] });
    }

    async function renderRoutesWithShade(result, preferShade) {
      const b = computeBoundsFromRoutes(result);
      if (b) {
        await fetchBuildingsForBounds(b.north, b.south, b.east, b.west);
      }
      drawRoutes(result, preferShade);
    }

    window.initGoogle = function() {
      // called by Google JS API once loaded
      directionsService = new google.maps.DirectionsService();
      const acOptions = { fields: ["geometry", "name", "formatted_address"], componentRestrictions: { country: "us" } };
      try {
        new google.maps.places.Autocomplete(document.getElementById('start-input'), acOptions);
        new google.maps.places.Autocomplete(document.getElementById('end-input'), acOptions);
      } catch (e) { console.warn('Autocomplete init failed', e); }
      window.googleReady = true;
    };

    /* Controls setup */
    // Google Directions service is created in initGoogle() after async load

    const startInput = document.getElementById('start-input');
    const endInput = document.getElementById('end-input');
    const routeBtn = document.getElementById('route-btn');
    const preferShadeChk = document.getElementById('prefer-shade');

    async function requestRoutes(origin, destination) {
      if (!window.googleReady || !directionsService) throw new Error('Google API not ready');
      return new Promise((resolve, reject) => {
        directionsService.route({
          origin,
          destination,
          travelMode: google.maps.TravelMode.WALKING,
          provideRouteAlternatives: true,
          optimizeWaypoints: false
        }, (result, status) => {
          if (status === 'OK' || status === google.maps.DirectionsStatus?.OK) resolve(result);
          else reject(new Error('Directions request failed: ' + status));
        });
      });
    }

    routeBtn.addEventListener('click', async () => {
      const origin = startInput.value.trim();
      const destination = endInput.value.trim();
      if (!origin || !destination) { alert('Enter start and end.'); return; }
      // Stop any running timers while routing
      if (animTimerId) { clearInterval(animTimerId); animTimerId = null; }
      stopBaseClock();
      routeBtn.disabled = true;
      loaderEl.innerText = 'Routing...';
      try {
        const result = await requestRoutes(origin, destination);
        lastDirectionsResult = result;
        await renderRoutesWithShade(result, preferShadeChk.checked);
        loaderEl.innerText = '';
      } catch (err) {
        console.error(err);
        loaderEl.innerText = 'Route error';
        alert('Could not fetch routes. Check API key and inputs.');
      } finally {
        routeBtn.disabled = false;
      }
    });

    preferShadeChk.addEventListener('change', async () => {
      if (lastDirectionsResult) {
        loaderEl.innerText = 'Scoring...';
        await renderRoutesWithShade(lastDirectionsResult, preferShadeChk.checked);
        loaderEl.innerText = '';
      }
    });

    increment.addEventListener('click', () => {
      now = new Date(now.getTime() + 3600000);
      shadeMap.setDate(now);
      updateTimeDisplay();
    });

    decrement.addEventListener('click', () => {
      now = new Date(now.getTime() - 3600000);
      shadeMap.setDate(now);
      updateTimeDisplay();
    });

    play.addEventListener('click', () => {
      if (animTimerId) { clearInterval(animTimerId); animTimerId = null; }
      stopBaseClock();
      isPlaying = true;
      animTimerId = setInterval(() => {
        now = new Date(now.getTime() + 60000); // +1 minute per tick
        shadeMap.setDate(now);
        updateTimeDisplay();
      }, 100);
    });

    stopBtn.addEventListener('click', () => {
      if (animTimerId) {
        clearInterval(animTimerId);
        animTimerId = null;
      }
      isPlaying = false;
      startBaseClock();
    });

    exposure.addEventListener('click', (e) => {
      const target = e.target;
      if (!target.checked) {
        shadeMap && shadeMap.setSunExposure(false);
        increment.disabled = false;
        decrement.disabled = false;
        play.disabled = false;
        stopBtn.disabled = false;
        exposureGradientContainer.style.display = 'none';
      } else {
        const { lat, lng } = map.getCenter();
        const { sunrise, sunset } = SunCalc.getTimes(now, lat, lng);
        shadeMap && shadeMap.setSunExposure(true, {
          startDate: sunrise,
          endDate: sunset
        });
        increment.disabled = true;
        decrement.disabled = true;
        play.disabled = true;
        stopBtn.disabled = true;

        const hours = (sunset - sunrise) / 1000 / 3600;
        const partial = hours - Math.floor(hours);
        const html = [];
        for (let i = 0; i < hours; i++) {
          html.push(`<div>${i + 1}</div>`);
        }
        html.push(`<div style="flex: ${partial}"></div>`);
        exposureGradientContainer.style.display = 'block';
        exposureGradient.innerHTML = html.join('');
      }
      updateTimeDisplay();
    });
  </script>
</body>

  <div id="sporky-gif">
    <img src="sporky.gif" alt="Sporky Mascot" />
  </div>

</html>